<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="../_static/favicon.ico">
    <title>引擎与连接 - GINO 1.1.0a0 文档</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async
            src="https://www.googletagmanager.com/gtag/js?id=UA-3759436-10"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag () {
            dataLayer.push(arguments);
        }

        gtag('js', new Date());

        gtag('config', 'UA-3759436-10');
    </script>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700&display=swap">
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css">
    <link type="text/css" rel="stylesheet"
          href="../_static/css/materialize.min.css"
          media="screen,projection"/>
    <link rel="stylesheet" href="../_static/pygments.css"
          type="text/css"/>
    <link type="text/css" rel="stylesheet"
          href="../_static/css/gino.css"/>
</head>
<body>

<header>
    <div class="navbar-fixed">
        <nav>
            <div class="nav-wrapper">
                <a href="#" data-target="sidenav" class="sidenav-trigger"><hr><hr><hr></a>
                <a href="../index.html" class="brand-logo">
                    <div class="img"
                         style="background-image: url(../_static/logo.svg); width: 103px; height: 40px;"></div>
                </a>
                <div class="breadcrumbs">
                    <a class="breadcrumb" style="display: none"></a>
                    
                        <a href="../explanation.html"
                           class="breadcrumb">原理说明</a>
                    
                    
                        <a class="breadcrumb" style="color: #FFFFFF">引擎与连接</a>
                    
                </div>
                <div class="spacer"></div>
                <div id="search-container" class="search">
                    <input type="text" id="search" placeholder="搜索">
                    <i class="mdi mdi-magnify"></i>
                    <div id="search-results" style="display: none"></div>
                </div>
                <a class="btn-flat theme-dark" href="/">
                    首页
                </a>
                <a class="btn-flat theme-dark" href="/authors.html">
                    鸣谢
                </a>
                <a href="https://github.com/python-gino/gino" target="_blank"
                   class="github-stars">
                    <div class="left"><img
                        src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDNweCIgaGVpZ2h0PSI0MnB4IiB2aWV3Qm94PSIwIDAgNDMgNDIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDYxLjIgKDg5NjUzKSAtIGh0dHBzOi8vc2tldGNoLmNvbSAtLT4KICAgIDx0aXRsZT5GaWxsIDQ5PC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IlYzLeacgOaWsOeov+S7tiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9IkhPTUUtdjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNTA3LjAwMDAwMCwgLTQ5LjAwMDAwMCkiIGZpbGw9IiNGRkZGRkUiPgogICAgICAgICAgICA8ZyBpZD0iYmFubmVyLWJnIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzc5LjAwMDAwMCwgLTE4Ny4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJoZWFkZXIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU5Ny4wMDAwMDAsIDIxOC4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMxMC40OTgwMiwxOCBDMTI5OC42MjcxMiwxOCAxMjg5LDI3LjYzOTg4MzEgMTI4OSwzOS41MzIxMTIzIEMxMjg5LDQ5LjA0NTEwMjYgMTI5NS4xNTk4Myw1Ny4xMTQ2ODggMTMwMy43MDMzNCw1OS45NjE4NDM5IEMxMzA0Ljc3OTAzLDYwLjE2MDExMzggMTMwNS4xNzEwMyw1OS40OTUyNDg3IDEzMDUuMTcxMDMsNTguOTI0MjMxMyBDMTMwNS4xNzEwMyw1OC40MTI2OTUgMTMwNS4xNTI1NSw1Ny4wNTkxNzI0IDEzMDUuMTQxOTksNTUuMjYyODQ3IEMxMjk5LjE2MTY3LDU2LjU2MzQ5NzYgMTI5Ny44OTk4Nyw1Mi4zNzYwMzcxIDEyOTcuODk5ODcsNTIuMzc2MDM3MSBDMTI5Ni45MjE4NSw0OS44ODg0MTA2IDEyOTUuNTEyMjMsNDkuMjI2MTg5MSAxMjk1LjUxMjIzLDQ5LjIyNjE4OTEgQzEyOTMuNTYwMTUsNDcuODkxMTcxNyAxMjk1LjY2MDA2LDQ3LjkxNzYwNzcgMTI5NS42NjAwNiw0Ny45MTc2MDc3IEMxMjk3LjgxODA0LDQ4LjA2OTYxNDYgMTI5OC45NTMxMyw1MC4xMzY5MDg5IDEyOTguOTUzMTMsNTAuMTM2OTA4OSBDMTMwMC44NzA5LDUzLjQyNjg2NzYgMTMwMy45ODU3OSw1Mi40NzY0OTM4IDEzMDUuMjEwNjMsNTEuOTI1MzAzNSBDMTMwNS40MDU5Nyw1MC41MzQ3NzA1IDEzMDUuOTYxNjMsNDkuNTg1NzE4NiAxMzA2LjU3NTM3LDQ5LjA0Nzc0NjIgQzEzMDEuODAxNDEsNDguNTA0NDg2NiAxMjk2Ljc4MTk1LDQ2LjY1NjYxMTEgMTI5Ni43ODE5NSwzOC40MDU5MzkyIEMxMjk2Ljc4MTk1LDM2LjA1NTc3OTkgMTI5Ny42MjAwNiwzNC4xMzI1NjE3IDEyOTguOTk1MzcsMzIuNjI4MzU0IEMxMjk4Ljc3MzYzLDMyLjA4Mzc3MjYgMTI5OC4wMzU4MiwyOS44OTM1NTEgMTI5OS4yMDY1NCwyNi45MzAwNzY4IEMxMjk5LjIwNjU0LDI2LjkzMDA3NjggMTMwMS4wMTA4LDI2LjM1MTEyODYgMTMwNS4xMTgyNCwyOS4xMzc0ODE4IEMxMzA2LjgzMjc1LDI4LjY1ODk5MDQgMTMwOC42NzI2NCwyOC40MjEwNjY1IDEzMTAuNTAwNjYsMjguNDExODEzOSBDMTMxMi4zMjczNiwyOC40MjEwNjY1IDEzMTQuMTY1OTQsMjguNjU4OTkwNCAxMzE1Ljg4MzA4LDI5LjEzNzQ4MTggQzEzMTkuOTg3ODgsMjYuMzUxMTI4NiAxMzIxLjc4OTUsMjYuOTMwMDc2OCAxMzIxLjc4OTUsMjYuOTMwMDc2OCBDMTMyMi45NjI4NiwyOS44OTM1NTEgMTMyMi4yMjUwNSwzMi4wODM3NzI2IDEzMjIuMDA0NjMsMzIuNjI4MzU0IEMxMzIzLjM4MjU4LDM0LjEzMjU2MTcgMTMyNC4yMTQwOSwzNi4wNTU3Nzk5IDEzMjQuMjE0MDksMzguNDA1OTM5MiBDMTMyNC4yMTQwOSw0Ni42Nzc3NTk5IDEzMTkuMTg2NzIsNDguNDk3ODc3NiAxMzE0LjM5ODIzLDQ5LjAzMDU2MjggQzEzMTUuMTY5MDQsNDkuNjk1NDI3OSAxMzE1Ljg1NjY5LDUxLjAwOTI5NjUgMTMxNS44NTY2OSw1My4wMTcxMDk4IEMxMzE1Ljg1NjY5LDU1Ljg5NTk4ODkgMTMxNS44MzAyOSw1OC4yMTgzOTA1IDEzMTUuODMwMjksNTguOTI0MjMxMyBDMTMxNS44MzAyOSw1OS41MDA1MzU5IDEzMTYuMjE4MzMsNjAuMTcwNjg4MiAxMzE3LjMwODU0LDU5Ljk2MDUyMjEgQzEzMjUuODQ1NDUsNTcuMTA2NzU3MiAxMzMyLDQ5LjA0MjQ1OSAxMzMyLDM5LjUzMjExMjMgQzEzMzIsMjcuNjM5ODgzMSAxMzIyLjM3Mjg4LDE4IDEzMTAuNDk4MDIsMTgiIGlkPSJGaWxsLTQ5Ij48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="
                        class="github-logo">
                        GitHub
                    </div>
                    <div class="right"><img
                        src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjFweCIgaGVpZ2h0PSIxOXB4IiB2aWV3Qm94PSIwIDAgMjEgMTkiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDYxLjIgKDg5NjUzKSAtIGh0dHBzOi8vc2tldGNoLmNvbSAtLT4KICAgIDx0aXRsZT5QYXRoPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IlYzLeacgOaWsOeov+S7tiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9IkhPTUUtdjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNTYxLjAwMDAwMCwgLTYwLjAwMDAwMCkiIGZpbGw9IiNGOEQyMzAiPgogICAgICAgICAgICA8ZyBpZD0iYmFubmVyLWJnIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzc5LjAwMDAwMCwgLTE4Ny4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJoZWFkZXIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU5Ny4wMDAwMDAsIDIxOC4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0ibGFiZWwtY29weS0xMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTI4OS4wMDAwMDAsIDE4LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aCIgcG9pbnRzPSI2MS4wNTQzNTQzIDE3Ljc1NzM4MzYgNTQuMjE1MjQ2NiAxOC4zMTMzOTI5IDU5Ljg4OTM1MTcgMjIuOTczNzM4NyA1Ny43ODQ1MjI4IDI5Ljg0MDExODQgNjQuNDQyNTI3MSAyNi41NDM0MTg4IDcwLjU3NzcyMzkgMjkuODQwMTE4NCA2OS4yMzA0MzI1IDIyLjk3MzczODcgNzQuNzMyNTY5NiAxOC4zMTMzOTI5IDY3Ljg5MzQ2MiAxNy43NTczODM2IDY0LjQ0MjUyNzEgMTEuMzc1Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=">
                        <span id="github-star-num"></span>
                    </div>
                </a>
            </div>
        </nav>
    </div>

    <div id="sidenav" class="sidenav sidenav-fixed">
        <p class="caption"><span class="caption-text">上手教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">上手教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/announcement.html">官宣：Python 异步编程再添一利器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/tutorial.html">GINO 基础教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/fastapi.html">搭建一个 FastAPI 服务器</a></li>
</ul>
<p class="caption"><span class="caption-text">进阶用法</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../how-to.html">进阶用法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/alembic.html">使用 Alembic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/bakery.html">预制查询</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/contributing.html">贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/crud.html">增删改查</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/faq.html">常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/json-props.html">JSON 扩展属性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/loaders.html">加载器与关系</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/pool.html">连接池</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/schema.html">表结构定义</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/transaction.html">数据库事务</a></li>
</ul>
<p class="caption"><span class="caption-text">原理说明</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../explanation.html">原理说明</a></li>
<li class="toctree-l1"><a class="reference internal" href="async.html">异步编程基础</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">引擎与连接</a></li>
<li class="toctree-l1"><a class="reference internal" href="why.html">为什么要用异步 ORM？</a></li>
</ul>
<p class="caption"><span class="caption-text">参考手册</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference.html">参考手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/api.html">API 参考</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/extensions.html">扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/history.html">版本历史</a></li>
</ul>

    </div>
</header>

<main>
    <div class="row">
        <div class="col s12 m9 body">
            <div id="main-content" role="main">
                
    <div class="section" id="engine-and-connection">
<h1>引擎与连接<a class="headerlink" href="#engine-and-connection" title="永久链接至标题">¶</a></h1>
<p><a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine" title="gino.engine.GinoEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoEngine</span></code></a> is the core of GINO. It acts like a pool of
connections but also does the work of assembling everyone together:</p>
<img alt="../_images/engine.png" class="align-center" src="../_images/engine.png" />
<p>Under the hood, engine is associated with a specific dialect instance on
creation, e.g. asyncpg dialect. The dialect is actually a set of classes that
implements GINO dialect API, offering all the details about how to operate on
this specific database. In the diagram, gray color means internal, while green
means touchable by end users.</p>
<p>During creation, the engine will also ask the dialect to create a database
connection pool for it. The pool type is also a part of the dialect API,
because asynchronous database drivers usually have their own pool
implementation, thus their GINO dialects should hide such implementation
differences behind the unified diagram API for engine to use.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>In SQLAlchemy, database drivers are supposed to follow the DB-API standard,
which does not usually provide a pool implementation. Therefore, SQLAlchemy
has its own pool implementation, created directly in engine. This is where
this diagram doesn't fit SQLAlchemy.</p>
</div>
<p>The pool creates raw connections, not the <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a>
green in the diagram. The connection in the diagram is a many-to-one wrapper of
the raw connection, because of the reuse and lazy features, we'll get to that
part later. The connection is created by the engine, thus inherits the same
dialect, and is used for running queries.</p>
<p>On the outer side, SQLAlchemy queries can be executed directly on the engine or
connection. When on engine, it will try to acquire a reusable connection to
actually execute the connection, and release the connection after use.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Another difference to SQLAlchemy here: GINO execution methods always return
final results, while in SQLAlchemy accessing the result may cause further
implicit database accesses. Therefore GINO engine immediately releases the
connection when the execution method on the engine returns, but SQLAlchemy
can only release the connection implicitly when the result data is found
exhausted.</p>
<p>By immediately releasing a connection, GINO may not release the related raw
connection when the raw connection was reused from another parent
connection. We'll get to this later.</p>
</div>
<p>GINO also supports <a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/connections.html#connectionless-execution-implicit-execution">implicit execution</a>
without having to specify an engine or connection explicitly. This is done by
binding the engine to the <code class="docutils literal notranslate"><span class="pre">db</span></code> instance, also known as the
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData" title="(在 SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> or the <a class="reference internal" href="../reference/api/gino.api.html#gino.api.Gino" title="gino.api.Gino"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gino</span></code></a> instance.
You may possibly bind a <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> instance, but that
is greatly not recommended because it is very much untested.</p>
<p>At last, as the ORM / CRUD feature, models are just add-ons on top of
everything else to generate queries. The parent model class is connected to a
<code class="docutils literal notranslate"><span class="pre">db</span></code> instance on creation, therefore the models can do implicit execution too
if their <code class="docutils literal notranslate"><span class="pre">db</span></code> has a bind.</p>
<p>Then let's get to some details.</p>
<div class="section" id="creating-engines">
<h2>Creating Engines<a class="headerlink" href="#creating-engines" title="永久链接至标题">¶</a></h2>
<p>GINO reuses the strategy system SQLAlchemy provides to create engines. The name
of GINO's strategy to create asynchronous <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine" title="gino.engine.GinoEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoEngine</span></code></a> is
just <code class="docutils literal notranslate"><span class="pre">gino</span></code>, but only available after <code class="docutils literal notranslate"><span class="pre">gino</span></code> is imported:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gino</span><span class="o">,</span> <span class="nn">sqlalchemy</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">e</span> <span class="o">=</span> <span class="k">await</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;gino&#39;</span><span class="p">)</span>
    <span class="c1"># e is a GinoEngine</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>Please read <a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls">this SQLAlchemy document</a>
to learn about writing database URLs.</p>
</div>
<p>Also the GINO strategy replaces the default driver of dialect <code class="docutils literal notranslate"><span class="pre">postgresql://</span></code>
from <code class="docutils literal notranslate"><span class="pre">psycopg2</span></code> to <code class="docutils literal notranslate"><span class="pre">asyncpg</span></code>, so that you don't have to replace the URL
as it may be shared between GINO and vanilla SQLAlchemy in parallel.
Alternatively, you can explicitly specify the driver to use by
<code class="docutils literal notranslate"><span class="pre">postgresql+asyncpg://...</span></code> or just <code class="docutils literal notranslate"><span class="pre">asyncpg://...</span></code>.</p>
<p>GINO also offers a shortcut as <a class="reference internal" href="../reference/api/gino.html#gino.create_engine" title="gino.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">gino.create_engine()</span></code></a>, which only sets the
default strategy to <code class="docutils literal notranslate"><span class="pre">gino</span></code> and does nothing more. So here is an identical
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gino</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">e</span> <span class="o">=</span> <span class="k">await</span> <span class="n">gino</span><span class="o">.</span><span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">)</span>
    <span class="c1"># e is also a GinoEngine</span>
</pre></div>
</div>
<p>As you may have noticed, when using the GINO strategy,
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/engines.html#sqlalchemy.create_engine" title="(在 SQLAlchemy v1.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> returns a coroutine, which must be awaited
for result. Because it will create a database connection pool behind the scene,
and actually making a few initial connections by default.</p>
<p>For it is just SQLAlchemy <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/engines.html#sqlalchemy.create_engine" title="(在 SQLAlchemy v1.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>, the same rules of
parameters apply in GINO too. Well for now, GINO only supports a small amount
of all the parameters listed in SQLAlchemy document (we are working on it!):</p>
<p>For Dialect:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine.params.isolation_level">isolation_level</a></p></li>
<li><p><a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine.params.paramstyle">paramstyle</a></p></li>
</ul>
<p>For Engine:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine.params.echo">echo</a></p></li>
<li><p><a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine.params.execution_options">execution_options</a></p></li>
<li><p><a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine.params.logging_name">logging_name</a></p></li>
</ul>
<p>While these parameters are discarded by GINO:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine.params.module">module</a></p></li>
</ul>
<p>In addition, keyword arguments for creating the underlying pool is accepted
here. In the case of asyncpg, they are from <a class="reference external" href="https://magicstack.github.io/asyncpg/current/api/index.html#asyncpg.pool.create_pool" title="(在 asyncpg v0.20.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_pool()</span></code></a>.
For example, we can create an engine without initial connections:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="k">await</span> <span class="n">gino</span><span class="o">.</span><span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Similar to SQLAlchemy, GINO also provides shortcut to create engine while
setting it as a bind. In SQLAlchemy it is like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlalchemy</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">MetaData</span><span class="p">()</span>
<span class="n">metadata</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="s1">&#39;postgresql://...&#39;</span>

<span class="c1"># or in short</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">MetaData</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This implicitly calls <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/engines.html#sqlalchemy.create_engine" title="(在 SQLAlchemy v1.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> under the hood. However
in GINO, creating an engine requires <code class="docutils literal notranslate"><span class="pre">await</span></code>, it can no longer be hidden
behind a normal assignment statement. Therefore, GINO removed the assignment
magic in subclass <a class="reference internal" href="../reference/api/gino.api.html#gino.api.Gino" title="gino.api.Gino"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gino</span></code></a>, reverted it to simple assignment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gino</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">gino</span><span class="o">.</span><span class="n">Gino</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># db.bind = &#39;postgresql://...&#39; doesn&#39;t work!! It sets a string on bind</span>
    <span class="n">engine</span> <span class="o">=</span> <span class="k">await</span> <span class="n">gino</span><span class="o">.</span><span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">engine</span>
</pre></div>
</div>
<p>And provided a shortcut to do so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="k">await</span> <span class="n">db</span><span class="o">.</span><span class="n">set_bind</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>And another simpler shortcut for one-time usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">db</span> <span class="o">=</span> <span class="k">await</span> <span class="n">gino</span><span class="o">.</span><span class="n">Gino</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To unset a bind and close the engine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">bind</span><span class="p">,</span> <span class="kc">None</span>
<span class="k">await</span> <span class="n">engine</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Or with a shortcut correspondingly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="n">engine</span><span class="o">.</span><span class="n">pop_bind</span><span class="p">()</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Furthermore, the two steps can be combined into one shortcut with asynchronous
context manager:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">db</span><span class="o">.</span><span class="n">with_bind</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">engine</span><span class="p">:</span>
    <span class="c1"># your code here</span>
</pre></div>
</div>
</div>
<div class="section" id="managing-connections">
<h2>Managing Connections<a class="headerlink" href="#managing-connections" title="永久链接至标题">¶</a></h2>
<p>With a <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine" title="gino.engine.GinoEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoEngine</span></code></a> at hand, you can acquire connections
from the pool now:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conn</span> <span class="o">=</span> <span class="k">await</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
</pre></div>
</div>
<p>Don't forget to release it after use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p>Yes this can be easily missing. The recommended way is to use the asynchronous
context manager:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="c1"># play with the connection</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">conn</span></code> is a <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> instance. As mentioned
previously, <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> is mapped to an underlying raw
connection, as shown in following diagram:</p>
<img alt="../_images/connection.png" class="align-center" src="../_images/connection.png" />
<p>Each column has at most one actual raw connection, and the number is the
sequence the connections are created in this example. It is designed this way
so that GINO could offer two features for connection management: <code class="docutils literal notranslate"><span class="pre">reuse</span></code> and
<code class="docutils literal notranslate"><span class="pre">lazy</span></code>. They are keyword arguments on <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine.acquire" title="gino.engine.GinoEngine.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a>
and by default switched off.</p>
<div class="section" id="reuse">
<h3>reuse<a class="headerlink" href="#reuse" title="永久链接至标题">¶</a></h3>
<p>When acquiring a <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> (2), GINO will borrow a
raw connection (1) from the underlying pool first, and assign it to this
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> (2). This is the default behavior of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code> with no arguments given. Even when
you are nesting two acquires, you still get two actual raw connection
borrowed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn1</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn2</span><span class="p">:</span>
        <span class="c1"># conn2 is a completely different connection than conn1</span>
</pre></div>
</div>
<p>But sometimes <code class="docutils literal notranslate"><span class="pre">conn2</span></code> may exist in a different method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn1</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">inner</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn2</span><span class="p">:</span>
        <span class="c1"># ...</span>
</pre></div>
</div>
<p>And we probably wish <code class="docutils literal notranslate"><span class="pre">inner</span></code> could reuse the same raw connection in
<code class="docutils literal notranslate"><span class="pre">outer</span></code> to save some resource, or borrow a new one if <code class="docutils literal notranslate"><span class="pre">inner</span></code> is
individually called without <code class="docutils literal notranslate"><span class="pre">outer</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn1</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">inner</span><span class="p">(</span><span class="n">conn1</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">conn2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">conn2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn2</span><span class="p">:</span>
            <span class="c1"># ...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># the same ... again</span>
</pre></div>
</div>
<p>This is exactly the scenario <code class="docutils literal notranslate"><span class="pre">reuse</span></code> could be useful. We can simply tell the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code> to reuse the most recent reusable
connection in current context by setting <code class="docutils literal notranslate"><span class="pre">reuse=True</span></code>, as presented in this
identical example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn1</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">inner</span><span class="p">(</span><span class="n">conn1</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">reuse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn2</span><span class="p">:</span>
        <span class="c1"># ...</span>
</pre></div>
</div>
<p>Back to previous diagram, the blue <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a>
instances (3, 4, 6) are &quot;reusing connections&quot; acquired with <code class="docutils literal notranslate"><span class="pre">reuse=True</span></code>,
while the green ones (2, 5, 7) are not, thus they become &quot;reusable
connections&quot;. The green reusable connections are put in a stack in current
context, so that <code class="docutils literal notranslate"><span class="pre">acquire(reuse=True)</span></code> always reuses the most recent
connection at the top of the stack. For example, (3) and (4) reuse the only
available (2) at that moment, therefore (2, 3, 4) all map to the same raw
connection (1). Then after (5), (6) no longer reuses (2) because (5) is now the
new head of the stack.</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>By context, we are actually referring to the context concept in
<a class="reference external" href="https://docs.python.org/3.7/library/contextvars.html">contextvars</a> the
new module in Python 3.7, and its partial backport <a class="reference external" href="https://github.com/fantix/aiocontextvars">aiocontextvars</a>. Simply speaking, you may
treat a series of function calls in a chain as in the same context, even if
there is an <code class="docutils literal notranslate"><span class="pre">await</span></code>. It's something like a thread local in asyncio.</p>
</div>
<p><a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> (2) may be created through
<code class="docutils literal notranslate"><span class="pre">acquire(reuse=True)</span></code> too - because the stack is empty before (2), there is
nothing to reuse, so (2) upgraded itself to a reusable connection.</p>
<p>Releasing a reusing connection won't cause the reused raw connection being
returned to the pool, only directly releasing the reused
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> can do so. Connections should be released
in the reversed order as they are acquired, but if the reused connection is
released before reusing connections by accident, then all the reusing
connections depending on it will turn closed because they are reusing the same
raw connection which is returned to the pool, any further execution will fail.
For example, if (3) is released first, then (2) and (4) are still functional.
But if (2) is released first, then (3) and (4) will be released implicitly and
are no longer usable any more.</p>
</div>
<div class="section" id="lazy">
<h3>lazy<a class="headerlink" href="#lazy" title="永久链接至标题">¶</a></h3>
<p>As you may have found, <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> (5) does not have
an underlying raw connection, even when it is reused by (6). This is because
both (5) and (6) set <code class="docutils literal notranslate"><span class="pre">lazy=True</span></code> on acquire.</p>
<p>A lazy connection will not borrow a raw connection on creation, it will only do
so when have to, e.g. when executing a query or starting a transaction. For
example, <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> (7) is acquired lazily without a
raw connection, and (8) is only created when a query is executed on (7):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>  <span class="c1"># (7)</span>
    <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="s1">&#39;select now()&#39;</span><span class="p">)</span>          <span class="c1"># (8)</span>
</pre></div>
</div>
<p>On implementation level, <code class="docutils literal notranslate"><span class="pre">lazy</span></code> is extremely easy in
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine.acquire" title="gino.engine.GinoEngine.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a>: if <code class="docutils literal notranslate"><span class="pre">lazy=False</span></code> then borrow a raw
connection, else do nothing. That's it. Before executing a query or starting a
transaction, <code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code> will always try to borrow a
raw connection if there is none present. This allows GINO to &quot;transiently
release&quot; a raw connection, while all <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a>
mapped to this raw connection are put in lazy mode (again). This is especially
useful before you need to run some networking tasks in a database-related
context - the networking task may take a long time to finish, we don't want to
waste a connection resource checked out for nothing. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>  <span class="c1"># (7)</span>
    <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="s1">&#39;select now()&#39;</span><span class="p">)</span>          <span class="c1"># (8)</span>
    <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">release</span><span class="p">(</span><span class="n">permanent</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>        <span class="c1"># release (8)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>                    <span class="c1"># simulate long I/O work</span>
    <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="s1">&#39;select now()&#39;</span><span class="p">)</span>          <span class="c1"># re-acquire a new raw connection,</span>
                                               <span class="c1">#   not necessarily the same (8)</span>
</pre></div>
</div>
<p>When used together with <code class="docutils literal notranslate"><span class="pre">reuse</span></code>, at most one raw connection may be borrowed
for one reusing chain. For example, executing queries on both (5) and (6) will
result only one raw connection checked out, no matter which executes first. It
is also worth noting that, if we set <code class="docutils literal notranslate"><span class="pre">lazy=False</span></code> on (6), then the raw
connection will be immediately borrowed on acquire, and shared between both (5)
and (6). It's been quite a while, let me post the same diagram again:</p>
<img alt="../_images/connection.png" class="align-center" src="../_images/connection.png" />
</div>
<div class="section" id="reusable">
<h3>reusable<a class="headerlink" href="#reusable" title="永久链接至标题">¶</a></h3>
<p>Usually, you don't have to worry about the two options <code class="docutils literal notranslate"><span class="pre">reuse</span></code> and <code class="docutils literal notranslate"><span class="pre">lazy</span></code>,
using the default <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine.acquire" title="gino.engine.GinoEngine.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> will always create
a concrete <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> with a new raw connection with
it. It is only that they are by default reusable (the green ones). If you need
an absolutely isolated unique connection that has no risk being reused, you may
use <code class="docutils literal notranslate"><span class="pre">reusable=False</span></code> on acquire. As shown in the diagram, the unreusable
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> is an orphan away from any stack:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">():</span>                    <span class="c1"># (2)</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">reusable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># the unreusable connection</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">reuse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># (3)</span>
</pre></div>
</div>
<p>Unreusable connections can be lazy. But it is usually meaningless to specify
both <code class="docutils literal notranslate"><span class="pre">reuse=True</span></code> and <code class="docutils literal notranslate"><span class="pre">reusable=False</span></code> at the same time, because reusing
connections are always unusable - they are also not in the stack. You cannot
reuse a reusing connection, you only reuse a reusable connection in the stack.
Making a reusing connection unreusable doesn't make its related reusable
connection unreusable. Hmm if this is getting more confusing, just don't use
<code class="docutils literal notranslate"><span class="pre">acquire(reuse=True,</span> <span class="pre">reusable=False)</span></code> unless you know what it does.</p>
</div>
<div class="section" id="current-connection">
<h3>current_connection<a class="headerlink" href="#current-connection" title="永久链接至标题">¶</a></h3>
<p>Except for all scenarios supported by above three options, there is still one
left out: we may want to acquire a reusing-only connection. There is no such
option to do so, but GINO could do the same thing through
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine.current_connection" title="gino.engine.GinoEngine.current_connection"><code class="xref py py-attr docutils literal notranslate"><span class="pre">current_connection</span></code></a> which is always the reusable
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> at the top of current stack, or <code class="docutils literal notranslate"><span class="pre">None</span></code>
if current stack is empty.</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>The different between <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine.current_connection" title="gino.engine.GinoEngine.current_connection"><code class="xref py py-attr docutils literal notranslate"><span class="pre">current_connection</span></code></a>
and <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine.acquire" title="gino.engine.GinoEngine.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire(reuse=True)</span></code></a> is, the
latter always produces a <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a>, while the
former may not.</p>
</div>
</div>
</div>
<div class="section" id="executing-queries">
<h2>Executing Queries<a class="headerlink" href="#executing-queries" title="永久链接至标题">¶</a></h2>
<p>Once you have a <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> instance, you can start
executing queries with it. There are 6 variants of the execute method:
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.all" title="gino.engine.GinoConnection.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a>,
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.first" title="gino.engine.GinoConnection.first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first()</span></code></a>,
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.one" title="gino.engine.GinoConnection.one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one()</span></code></a>,
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.one_or_none" title="gino.engine.GinoConnection.one_or_none"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one_or_none()</span></code></a>,
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.scalar" title="gino.engine.GinoConnection.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a> and
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.status" title="gino.engine.GinoConnection.status"><code class="xref py py-meth docutils literal notranslate"><span class="pre">status()</span></code></a>. They are basically the same:
accepting the same parameters, calling the same underlying methods. The
difference is how they treat the results:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.all" title="gino.engine.GinoConnection.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> returns all results in a
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(在 Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, which may be empty when the query has no result, empty but
still a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(在 Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.first" title="gino.engine.GinoConnection.first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first()</span></code></a> returns the first result directly,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if there is no result at all. There is usually some optimization
behind the scene to efficiently get only the first result, instead of loading
the full result set into memory.</p></li>
<li><p><a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.one" title="gino.engine.GinoConnection.one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one()</span></code></a> returns exactly one result. If there
is no result at all or if there are multiple results, an exception is raised.</p></li>
<li><p><a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.one_or_none" title="gino.engine.GinoConnection.one_or_none"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one_or_none()</span></code></a> is similar to
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.one" title="gino.engine.GinoConnection.one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">one()</span></code></a>, but it returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if there is
no result instead or raising an exception.</p></li>
<li><p><a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.scalar" title="gino.engine.GinoConnection.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar()</span></code></a> is similar to
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.first" title="gino.engine.GinoConnection.first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first()</span></code></a>, it returns the first value of the
first result. Quite convenient to just retrieve a scalar value from database,
like <code class="docutils literal notranslate"><span class="pre">NOW()</span></code>, <code class="docutils literal notranslate"><span class="pre">MAX()</span></code>, <code class="docutils literal notranslate"><span class="pre">COUNT()</span></code> or whatever generates a single value.
<code class="docutils literal notranslate"><span class="pre">None</span></code> is also returned when there is no result, it is up to you how to
distinguish no result and the first value is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p></li>
<li><p><a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.status" title="gino.engine.GinoConnection.status"><code class="xref py py-meth docutils literal notranslate"><span class="pre">status()</span></code></a> executes the query and discard all
the query results at all. Instead it returns the execution status line as it
is, usually a textual string. Note, there may be no optimization to only
return the status without loading the results, so make your query generate
nothing if you don't want any result.</p></li>
</ul>
<p>By &quot;result&quot;, I meant <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/connections.html#sqlalchemy.engine.RowProxy" title="(在 SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code></a> of SQLAlchemy - an
immutable row instance with both <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(在 Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(在 Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> interfaces.
Database values are translated twice before they are eventually stored in a
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/connections.html#sqlalchemy.engine.RowProxy" title="(在 SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code></a>: first by the database driver (dialect)
from network payload to Python objects (see <a class="reference external" href="https://magicstack.github.io/asyncpg/current/usage.html#type-conversion">Type Conversion</a> of
how asyncpg does this), second by SQLAlchemy
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/type_api.html#sqlalchemy.types.TypeEngine.result_processor" title="(在 SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">result_processor()</span></code></a> depending on the actual
type and dialect.</p>
<p>The arguments taken by these 4 methods are identical to the ones accepted by
SQLAlchemy <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/connections.html#sqlalchemy.engine.Connection.execute" title="(在 SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> (click to read more),
usually a plain string of SQL directly or a SQLAlchemy query clause, followed
by query parameters. In the case when multiple dictionaries are given to
<code class="docutils literal notranslate"><span class="pre">multiparams</span></code>, all 4 methods will always return <code class="docutils literal notranslate"><span class="pre">None</span></code> discarding all
results. Likewise, the parameter values are processed twice too: first by
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/type_api.html#sqlalchemy.types.TypeEngine.bind_processor" title="(在 SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind_processor()</span></code></a> then the database driver.</p>
<p>GINO also supports SQLAlchemy
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/connections.html#sqlalchemy.engine.Connection.execution_options" title="(在 SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execution_options()</span></code></a> provided either on
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine.update_execution_options" title="gino.engine.GinoEngine.update_execution_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">engine</span> <span class="pre">level</span></code></a>,
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.execution_options" title="gino.engine.GinoConnection.execution_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connection</span> <span class="pre">level</span></code></a> or on
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options" title="(在 SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">queries</span></code></a>. At
the moment we are working on being compatible with SQLAlchemy execution
options. In the mean while, GINO provides several new execution options, for
example enabling <code class="docutils literal notranslate"><span class="pre">return_model</span></code> and providing a <code class="docutils literal notranslate"><span class="pre">model</span></code> will make
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.all" title="gino.engine.GinoConnection.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> and
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.first" title="gino.engine.GinoConnection.first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first()</span></code></a> return ORM model instance(s) instead
of <a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/connections.html#sqlalchemy.engine.RowProxy" title="(在 SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code></a> instance(s). See also
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/connections.html#sqlalchemy.engine.Connection.execution_options" title="(在 SQLAlchemy v1.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execution_options()</span></code></a> for more information.</p>
<p>In addition, GINO has an <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection.iterate" title="gino.engine.GinoConnection.iterate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterate()</span></code></a> method to
traverse the query results progressively, instead of loading all the results at
once. This method takes the same arguments as the other 4 execute methods do,
and follows the same rule of data handling. For now with asyncpg, this creates
a <a class="reference external" href="https://magicstack.github.io/asyncpg/current/api/index.html#cursors">server-side cursor</a>.</p>
</div>
<div class="section" id="id1">
<h2>Implicit Execution<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>Acquire a <a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoConnection" title="gino.engine.GinoConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoConnection</span></code></a> and execute queries on it, that
is the most explicit way. You can also execute queries on a
<a class="reference internal" href="../reference/api/gino.engine.html#gino.engine.GinoEngine" title="gino.engine.GinoEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoEngine</span></code></a> instance. In this case, a connection will be
acquired with <code class="docutils literal notranslate"><span class="pre">reuse=True</span></code> for you implicitly, and released after returning:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="n">engine</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="s1">&#39;select now()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Equals to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">reuse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="s1">&#39;select now()&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This allows you to easily write connectionless code. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">get_now</span><span class="p">():</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">engine</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="s1">&#39;select now()&#39;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">acquire</span><span class="p">():</span>
        <span class="n">now</span> <span class="o">=</span> <span class="k">await</span> <span class="n">get_now</span><span class="p">()</span>
        <span class="k">await</span> <span class="n">engine</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s1">&#39;UPDATE ...&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">main()</span></code> will take only one raw connection. <code class="docutils literal notranslate"><span class="pre">get_now()</span></code>
can also work alone out of any <code class="docutils literal notranslate"><span class="pre">acquire()</span></code> context, thanks to <code class="docutils literal notranslate"><span class="pre">reuse</span></code>.</p>
<p>Furthermore, GINO provides the same query APIs on <a class="reference internal" href="../reference/api/gino.api.html#gino.api.Gino" title="gino.api.Gino"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gino</span></code></a>
directly. They are simply delegates to corresponding API methods on the
<code class="docutils literal notranslate"><span class="pre">bind</span></code>. This allows even engine-less programming:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">db</span> <span class="o">=</span> <span class="n">gino</span><span class="o">.</span><span class="n">Gino</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">get_now</span><span class="p">():</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">db</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="s1">&#39;select now()&#39;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">db</span><span class="o">.</span><span class="n">with_bind</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">):</span>
        <span class="n">now</span> <span class="o">=</span> <span class="k">await</span> <span class="n">get_now</span><span class="p">()</span>
        <span class="k">await</span> <span class="n">db</span><span class="o">.</span><span class="n">status</span><span class="p">(</span><span class="s1">&#39;UPDATE ...&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>In this example we didn't put the two queries in an <code class="docutils literal notranslate"><span class="pre">acquire()</span></code> block, so
they might be executed in two different connections.</p>
</div>
<p>At last, the SQLAlchemy <a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/connections.html#connectionless-execution-implicit-execution">implicit execution</a>
on queries also work in GINO, under an extension named <code class="docutils literal notranslate"><span class="pre">gino</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="n">users_table</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">gino</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>By default, the extension <a class="reference internal" href="../reference/api/gino.api.html#gino.api.GinoExecutor" title="gino.api.GinoExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GinoExecutor</span></code></a> is injected on
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/selectable.html#sqlalchemy.sql.expression.Executable" title="(在 SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executable</span></code></a> as a property of name <code class="docutils literal notranslate"><span class="pre">gino</span></code>
at the creation of <a class="reference internal" href="../reference/api/gino.api.html#gino.api.Gino" title="gino.api.Gino"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gino</span></code></a> instance. Therefore, any
<a class="reference external" href="https://docs.sqlalchemy.org/en/13/core/selectable.html#sqlalchemy.sql.expression.Executable" title="(在 SQLAlchemy v1.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executable</span></code></a> object has the <code class="docutils literal notranslate"><span class="pre">gino</span></code>
property for implicit execution. Similarly, the execution methods calls the
corresponding ones on the <code class="docutils literal notranslate"><span class="pre">bind</span></code> of the <code class="docutils literal notranslate"><span class="pre">db</span></code> instance.</p>
</div>
</div>


            </div>
            <p style="text-align: center; font-size: 12px;">
                <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
                    <img
                        alt="知识共享许可协议"
                        style="border-width:0"
                        src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
                    />
                </a>
                <br/>
                本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。
            </p>
        </div>

        <div class="col hide-on-small-only m3 right-nav">
            <div class="table-of-contents fixed">
                
                    <ul>
<li><a class="reference internal" href="#">引擎与连接</a><ul>
<li><a class="reference internal" href="#creating-engines">Creating Engines</a></li>
<li><a class="reference internal" href="#managing-connections">Managing Connections</a><ul>
<li><a class="reference internal" href="#reuse">reuse</a></li>
<li><a class="reference internal" href="#lazy">lazy</a></li>
<li><a class="reference internal" href="#reusable">reusable</a></li>
<li><a class="reference internal" href="#current-connection">current_connection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#executing-queries">Executing Queries</a></li>
<li><a class="reference internal" href="#id1">Implicit Execution</a></li>
</ul>
</li>
</ul>

                
                <div id="version-selector">
                    
                        <hr>
                    
                    
                        <div class="version-warning">
                            
                                您正在浏览 master 分支，该文档可能涉及尚未发布的功能。
                            
                        </div>
                    
                </div>
                <div class="add-your-lang">
                    <a href="https://www.transifex.com/decentfox-studio/gino_1_0/"
                       target="_blank">Add your language here.</a>
                </div>
            </div>
        </div>

    </div>
    <div class="fixed-action-btn click-to-toggle">
        <a class="btn-floating btn-large white">
            <img src="../_static/images/language.svg">
            <div>
              ZH
            </div>
        </a>
        <ul id="lang-selector">
        </ul>
    </div>
</main>

<script type="text/javascript" src="../_static/js/materialize.min.js"></script>
<script type="text/javascript" src="../_static/js/language_data.js"></script>
<script id="documentation_options" data-url_root="../" src="../_static/js/documentation_options.js"></script>
<script type="text/javascript" src="../_static/js/underscore.js"></script>
<script type="text/javascript" src="../_static/js/jquery.js"></script>
<script type="text/javascript">
    var sver = 'master';
    var language = 'zh';
    var pagename = 'explanation/engine';
</script>
<script type="text/javascript" src="../_static/js/gino.js"></script>
<script type="text/javascript" src="../searchindex.js"></script>
</body>
</html>