<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="../_static/favicon.ico">
    <title>异步编程基础 - GINO 1.1.0a0 文档</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async
            src="https://www.googletagmanager.com/gtag/js?id=UA-3759436-10"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag () {
            dataLayer.push(arguments);
        }

        gtag('js', new Date());

        gtag('config', 'UA-3759436-10');
    </script>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700&display=swap">
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css">
    <link type="text/css" rel="stylesheet"
          href="../_static/css/materialize.min.css"
          media="screen,projection"/>
    <link rel="stylesheet" href="../_static/pygments.css"
          type="text/css"/>
    <link type="text/css" rel="stylesheet"
          href="../_static/css/gino.css"/>
</head>
<body>

<header>
    <div class="navbar-fixed">
        <nav>
            <div class="nav-wrapper">
                <a href="#" data-target="sidenav" class="sidenav-trigger"><hr><hr><hr></a>
                <a href="../index.html" class="brand-logo">
                    <div class="img"
                         style="background-image: url(../_static/logo.svg); width: 103px; height: 40px;"></div>
                </a>
                <div class="breadcrumbs">
                    <a class="breadcrumb" style="display: none"></a>
                    
                        <a href="../explanation.html"
                           class="breadcrumb">原理说明</a>
                    
                    
                        <a class="breadcrumb" style="color: #FFFFFF">异步编程基础</a>
                    
                </div>
                <div class="spacer"></div>
                <div id="search-container" class="search">
                    <input type="text" id="search" placeholder="搜索">
                    <i class="mdi mdi-magnify"></i>
                    <div id="search-results" style="display: none"></div>
                </div>
                <a class="btn-flat theme-dark" href="/">
                    首页
                </a>
                <a class="btn-flat theme-dark" href="/authors.html">
                    鸣谢
                </a>
                <a href="https://github.com/python-gino/gino" target="_blank"
                   class="github-stars">
                    <div class="left"><img
                        src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDNweCIgaGVpZ2h0PSI0MnB4IiB2aWV3Qm94PSIwIDAgNDMgNDIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDYxLjIgKDg5NjUzKSAtIGh0dHBzOi8vc2tldGNoLmNvbSAtLT4KICAgIDx0aXRsZT5GaWxsIDQ5PC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IlYzLeacgOaWsOeov+S7tiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9IkhPTUUtdjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNTA3LjAwMDAwMCwgLTQ5LjAwMDAwMCkiIGZpbGw9IiNGRkZGRkUiPgogICAgICAgICAgICA8ZyBpZD0iYmFubmVyLWJnIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzc5LjAwMDAwMCwgLTE4Ny4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJoZWFkZXIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU5Ny4wMDAwMDAsIDIxOC4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMxMC40OTgwMiwxOCBDMTI5OC42MjcxMiwxOCAxMjg5LDI3LjYzOTg4MzEgMTI4OSwzOS41MzIxMTIzIEMxMjg5LDQ5LjA0NTEwMjYgMTI5NS4xNTk4Myw1Ny4xMTQ2ODggMTMwMy43MDMzNCw1OS45NjE4NDM5IEMxMzA0Ljc3OTAzLDYwLjE2MDExMzggMTMwNS4xNzEwMyw1OS40OTUyNDg3IDEzMDUuMTcxMDMsNTguOTI0MjMxMyBDMTMwNS4xNzEwMyw1OC40MTI2OTUgMTMwNS4xNTI1NSw1Ny4wNTkxNzI0IDEzMDUuMTQxOTksNTUuMjYyODQ3IEMxMjk5LjE2MTY3LDU2LjU2MzQ5NzYgMTI5Ny44OTk4Nyw1Mi4zNzYwMzcxIDEyOTcuODk5ODcsNTIuMzc2MDM3MSBDMTI5Ni45MjE4NSw0OS44ODg0MTA2IDEyOTUuNTEyMjMsNDkuMjI2MTg5MSAxMjk1LjUxMjIzLDQ5LjIyNjE4OTEgQzEyOTMuNTYwMTUsNDcuODkxMTcxNyAxMjk1LjY2MDA2LDQ3LjkxNzYwNzcgMTI5NS42NjAwNiw0Ny45MTc2MDc3IEMxMjk3LjgxODA0LDQ4LjA2OTYxNDYgMTI5OC45NTMxMyw1MC4xMzY5MDg5IDEyOTguOTUzMTMsNTAuMTM2OTA4OSBDMTMwMC44NzA5LDUzLjQyNjg2NzYgMTMwMy45ODU3OSw1Mi40NzY0OTM4IDEzMDUuMjEwNjMsNTEuOTI1MzAzNSBDMTMwNS40MDU5Nyw1MC41MzQ3NzA1IDEzMDUuOTYxNjMsNDkuNTg1NzE4NiAxMzA2LjU3NTM3LDQ5LjA0Nzc0NjIgQzEzMDEuODAxNDEsNDguNTA0NDg2NiAxMjk2Ljc4MTk1LDQ2LjY1NjYxMTEgMTI5Ni43ODE5NSwzOC40MDU5MzkyIEMxMjk2Ljc4MTk1LDM2LjA1NTc3OTkgMTI5Ny42MjAwNiwzNC4xMzI1NjE3IDEyOTguOTk1MzcsMzIuNjI4MzU0IEMxMjk4Ljc3MzYzLDMyLjA4Mzc3MjYgMTI5OC4wMzU4MiwyOS44OTM1NTEgMTI5OS4yMDY1NCwyNi45MzAwNzY4IEMxMjk5LjIwNjU0LDI2LjkzMDA3NjggMTMwMS4wMTA4LDI2LjM1MTEyODYgMTMwNS4xMTgyNCwyOS4xMzc0ODE4IEMxMzA2LjgzMjc1LDI4LjY1ODk5MDQgMTMwOC42NzI2NCwyOC40MjEwNjY1IDEzMTAuNTAwNjYsMjguNDExODEzOSBDMTMxMi4zMjczNiwyOC40MjEwNjY1IDEzMTQuMTY1OTQsMjguNjU4OTkwNCAxMzE1Ljg4MzA4LDI5LjEzNzQ4MTggQzEzMTkuOTg3ODgsMjYuMzUxMTI4NiAxMzIxLjc4OTUsMjYuOTMwMDc2OCAxMzIxLjc4OTUsMjYuOTMwMDc2OCBDMTMyMi45NjI4NiwyOS44OTM1NTEgMTMyMi4yMjUwNSwzMi4wODM3NzI2IDEzMjIuMDA0NjMsMzIuNjI4MzU0IEMxMzIzLjM4MjU4LDM0LjEzMjU2MTcgMTMyNC4yMTQwOSwzNi4wNTU3Nzk5IDEzMjQuMjE0MDksMzguNDA1OTM5MiBDMTMyNC4yMTQwOSw0Ni42Nzc3NTk5IDEzMTkuMTg2NzIsNDguNDk3ODc3NiAxMzE0LjM5ODIzLDQ5LjAzMDU2MjggQzEzMTUuMTY5MDQsNDkuNjk1NDI3OSAxMzE1Ljg1NjY5LDUxLjAwOTI5NjUgMTMxNS44NTY2OSw1My4wMTcxMDk4IEMxMzE1Ljg1NjY5LDU1Ljg5NTk4ODkgMTMxNS44MzAyOSw1OC4yMTgzOTA1IDEzMTUuODMwMjksNTguOTI0MjMxMyBDMTMxNS44MzAyOSw1OS41MDA1MzU5IDEzMTYuMjE4MzMsNjAuMTcwNjg4MiAxMzE3LjMwODU0LDU5Ljk2MDUyMjEgQzEzMjUuODQ1NDUsNTcuMTA2NzU3MiAxMzMyLDQ5LjA0MjQ1OSAxMzMyLDM5LjUzMjExMjMgQzEzMzIsMjcuNjM5ODgzMSAxMzIyLjM3Mjg4LDE4IDEzMTAuNDk4MDIsMTgiIGlkPSJGaWxsLTQ5Ij48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg=="
                        class="github-logo">
                        GitHub
                    </div>
                    <div class="right"><img
                        src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjFweCIgaGVpZ2h0PSIxOXB4IiB2aWV3Qm94PSIwIDAgMjEgMTkiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDYxLjIgKDg5NjUzKSAtIGh0dHBzOi8vc2tldGNoLmNvbSAtLT4KICAgIDx0aXRsZT5QYXRoPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IlYzLeacgOaWsOeov+S7tiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9IkhPTUUtdjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNTYxLjAwMDAwMCwgLTYwLjAwMDAwMCkiIGZpbGw9IiNGOEQyMzAiPgogICAgICAgICAgICA8ZyBpZD0iYmFubmVyLWJnIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzc5LjAwMDAwMCwgLTE4Ny4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIGlkPSJoZWFkZXIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU5Ny4wMDAwMDAsIDIxOC4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8ZyBpZD0ibGFiZWwtY29weS0xMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTI4OS4wMDAwMDAsIDE4LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aCIgcG9pbnRzPSI2MS4wNTQzNTQzIDE3Ljc1NzM4MzYgNTQuMjE1MjQ2NiAxOC4zMTMzOTI5IDU5Ljg4OTM1MTcgMjIuOTczNzM4NyA1Ny43ODQ1MjI4IDI5Ljg0MDExODQgNjQuNDQyNTI3MSAyNi41NDM0MTg4IDcwLjU3NzcyMzkgMjkuODQwMTE4NCA2OS4yMzA0MzI1IDIyLjk3MzczODcgNzQuNzMyNTY5NiAxOC4zMTMzOTI5IDY3Ljg5MzQ2MiAxNy43NTczODM2IDY0LjQ0MjUyNzEgMTEuMzc1Ij48L3BvbHlnb24+CiAgICAgICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=">
                        <span id="github-star-num"></span>
                    </div>
                </a>
            </div>
        </nav>
    </div>

    <div id="sidenav" class="sidenav sidenav-fixed">
        <p class="caption"><span class="caption-text">上手教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">上手教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/announcement.html">官宣：Python 异步编程再添一利器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/tutorial.html">GINO 基础教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/fastapi.html">搭建一个 FastAPI 服务器</a></li>
</ul>
<p class="caption"><span class="caption-text">进阶用法</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../how-to.html">进阶用法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/alembic.html">使用 Alembic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/bakery.html">预制查询</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/contributing.html">贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/crud.html">增删改查</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/faq.html">常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/json-props.html">JSON 扩展属性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/loaders.html">加载器与关系</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/pool.html">连接池</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/schema.html">表结构定义</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-to/transaction.html">数据库事务</a></li>
</ul>
<p class="caption"><span class="caption-text">原理说明</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../explanation.html">原理说明</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">异步编程基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="engine.html">引擎与连接</a></li>
<li class="toctree-l1"><a class="reference internal" href="why.html">为什么要用异步 ORM？</a></li>
</ul>
<p class="caption"><span class="caption-text">参考手册</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference.html">参考手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/api.html">API 参考</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/extensions.html">扩展</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/history.html">版本历史</a></li>
</ul>

    </div>
</header>

<main>
    <div class="row">
        <div class="col s12 m9 body">
            <div id="main-content" role="main">
                
    <div class="section" id="asynchronous-programming-101">
<h1>异步编程基础<a class="headerlink" href="#asynchronous-programming-101" title="永久链接至标题">¶</a></h1>
<div class="section" id="the-story">
<h2>一个经典场景<a class="headerlink" href="#the-story" title="永久链接至标题">¶</a></h2>
<p>假如现在我们想要去创建自己的搜索引擎，为了创建索引数据库，家境贫寒的我们使用了一台单核电脑去爬取网页（I/O型操作），然后再将这些网页内容进行处理（计算型操作）。这个过程如下图所示：</p>
<img alt="../_images/why_single_task.png" class="align-center" src="../_images/why_single_task.png" />
<p>We have lots of web pages to index, so we simply handle them one by one:</p>
<img alt="../_images/why_throughput.png" class="align-center" src="../_images/why_throughput.png" />
<p>Let's assume the time of each task is constant: each second, 2 tasks are done.
Thus we can say what the throughput of the current system is 2 tasks/sec. How
can we improve the throughput? An obvious answer is to add more CPU cores:</p>
<img alt="../_images/why_multicore.png" class="align-center" src="../_images/why_multicore.png" />
<p>This simply doubles our throughput to 4 tasks/sec, and linearly scales as we
add more CPU cores, if the network is not a bottleneck. But can we improve
the throughput for each CPU core? The answer is yes, we can use
multi-threading:</p>
<img alt="../_images/why_multithreading.png" class="align-center" src="../_images/why_multithreading.png" />
<p>Wait a second! The 2 threads barely finished 6 tasks in 2 seconds, a
throughput of only 2.7 tasks/sec, much lower than 4 tasks/sec with 2 cores.
What's wrong with multi-threading? From the diagram we can see:</p>
<ul class="simple">
<li><p>There are yellow bars taking up extra time.</p></li>
<li><p>The green bars can still overlap with any bar in the other thread, but</p></li>
<li><p>non-green bars cannot overlap with non-green bars in the other thread.</p></li>
</ul>
<p>The yellow bars are time taken by <a class="reference external" href="https://en.wikipedia.org/wiki/Context_switch">context switches</a>, a necessary part of allowing
multiple threads or processes to run on a single CPU core concurrently.
One CPU core can do only one thing at a time (let's assume a world without
<a class="reference external" href="https://en.wikipedia.org/wiki/Hyper-threading">Hyper-threading</a> or similar),
so in order to run several threads concurrently the CPU must <a class="reference external" href="https://en.wikipedia.org/wiki/Time-sharing">split its
time</a> into small
slices, and run a little bit of each thread within these slices. The yellow bar
is the overhead for the CPU to switch context to run a different thread. The
scale is a bit dramatic, but it helps with the point.</p>
<p>Wait again here, the green bars are overlapping between threads. Is the CPU
doing two things at the same time? No, the CPU is doing nothing in the middle
of the green bar, because it's waiting for the HTTP response (I/O). That's how
multi-threading could improve the throughput to 2.7 tasks/sec, instead of
decreasing it to 1.7 tasks/sec. You may try in real to run CPU-intensive
tasks with multi-threading on single core, there won't be any improvement. Like
the multiplexed red bars (in practice there might be more context switches
depending on the task), they appear to be running at the same time, but the
total time for all to finish is actually longer than running the tasks one
by one. That's also why this is called concurrency instead of parallelism.</p>
<p>As you might imagine, throughput will improve less with each additional thread,
until throughput begins to decrease because context switches are wasting too
much time, not to mention the extra memory footprint taken by new threads. It
is usually not practical to have tens of thousands of threads running on a single
CPU core. How, then, is it possible to have tens of thousands of I/O-bound tasks
running concurrently on a single CPU core? This is the once-famous <a class="reference external" href="https://en.wikipedia.org/wiki/C10k_problem">C10k
problem</a>, usually solved by
asynchronous I/O:</p>
<img alt="../_images/why_coroutine.png" class="align-center" src="../_images/why_coroutine.png" />
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Asynchronous I/O and coroutines are two different things, but they usually
go together. Here we will stick with coroutines for simplicity.</p>
</div>
<p>Awesome! The throughput is 3.7 tasks/sec, nearly as good as 4 tasks/sec of 2
CPU cores. Though this is not real data, compared to OS threads coroutines
do take much less time to context switch and have a lower memory footprint,
thus making them an ideal option for the C10k problem.</p>
</div>
<div class="section" id="cooperative-multitasking">
<h2>Cooperative multitasking<a class="headerlink" href="#cooperative-multitasking" title="永久链接至标题">¶</a></h2>
<p>So what is a coroutine?</p>
<p>In the last diagram above, you may have noticed a difference compared to the
previous diagrams: the green bars are overlapping within the same thread.
That is because the in the last diagram, our code is using asynchronous I/O,
whereas the previously we were using blocking I/O. As the name suggests, blocking
I/O will block the thread until the I/O result is ready. Thus, there can be only
one blocking I/O operation running in a thread at a time. To achieve concurrency
with  blocking I/O, either multi-threading or multi-processing must be used.
In contrast, asynchronous I/O allows thousands (or even more) of concurrent
I/O reads and writes within the same thread, with each I/O operation blocking
only the coroutine performing the I/O rather than the whole thread. Like
multi-threading, coroutines provide a means to have concurrency during I/O,
but unlike multi-threading this concurrency occurs within a single thread.</p>
<p>Threads are scheduled by the operating system using an approach called <a class="reference external" href="https://en.wikipedia.org/wiki/Preemption_(computing)">preemptive
multitasking</a>. For
example, in previous multi-threading diagram there was only one CPU core. When
Thread 2 tried to start processing the first web page content, Thread 1 hadn't
finished processing its own. The OS brutally interrupted Thread 1 and shared
some resource (time) for Thread 2. But Thread 1 also needed CPU time to finish
its processing at the same time, so in turn after a while the OS had to pause
Thread 2 and resume Thread 1. Depending on the size of the task, such turns may
happen several times, so that every thread may have a fair chance to run. It is
something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Thread 1: I wanna run!
OS: Okay, here you go...
Thread 2: I wanna run!
OS: Urh, alright one sec ... Thread 1, hold on for a while!
Thread 1: Well I&#39;m not done yet, but you are the boss.
OS: It won&#39;t be long. Thread 2 it&#39;s your turn now.
Thread 2: Yay! (&amp;%#$@..+*&amp;#)
Thread 1: Can I run now?
OS: Just a moment please ... Thread 2, give it a break!
Thread 2: Alright ... but I really need the CPU.
OS: You&#39;ll have it later. Thread 1, hurry up!
</pre></div>
</div>
<p>In contrast, coroutines are scheduled by themselves cooperatively with the help
of an event manager. The event manager lives in the same thread as the
coroutines and unlike the OS scheduler that forces context switches on threads,
the event manager acts only when coroutines pause themselves. A thread knows
when it wants to run, but coroutines don't - only the event manager knows which
coroutine should run. The event manager may only trigger the next coroutine to
run after the previous coroutine yields control to wait for an event (e.g.
wait for an HTTP response). This approach to achieve concurrency is called
<a class="reference external" href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperative multitasking</a>. It's like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Coroutine 1: Let me know when event A arrives. I&#39;m done here before that.
Event manager: Okay. What about you, coroutine 2?
Coroutine 2: Um I&#39;ve got nothing to do here before event B.
Event manager: Cool, I&#39;ll be watching.
Event manager: (after a while) Hey coroutine 1, event A is here!
Coroutine 1: Awesome! Let me see ... looks good, but I need event C now.
Event manager: Very well. Seems event B arrived just now, coroutine 2?
Coroutine 2: Oh wonderful! Let me store it in a file ... There! I&#39;m all done.
Event manager: Sweet! Since there&#39;s no sign of event C yet, I&#39;ll sleep for a while.
(silence)
Event manager: Damn, event C timed out!
Coroutine 1: Arrrrh gotta kill myself with an exception :S
Event manager: Up to you :/
</pre></div>
</div>
<p>For coroutines, a task cannot be paused externally, the task can only pause
itself from within. When there are a lot of coroutines, concurrency depends on
each of them pausing from time to time to wait for events. If you wrote a
coroutine that never paused, it would allow no concurrency at all when running
because no other coroutine would have a chance to run. On the other hand, you
can feel safe in the code between pauses, because no other coroutine can
run at the same time to mess up shared states. That's why in the last diagram,
the red bars are not interleaved like threads.</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>In Python and asyncio, <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> declares coroutines, <code class="docutils literal notranslate"><span class="pre">await</span></code> yields
control to event loop (event manager).</p>
</div>
</div>
<div class="section" id="pros-and-cons">
<h2>Pros and cons<a class="headerlink" href="#pros-and-cons" title="永久链接至标题">¶</a></h2>
<p>Asynchronous I/O may handle tens of thousands of concurrent I/O operations in
the same thread. This can save a lot of CPU time from context switching, and
memory from multi-threading. Therefore if you are dealing with lots of I/O-bound
tasks concurrently, asynchronous I/O can efficiently use limited CPU and memory to
deliver greater throughput.</p>
<p>With coroutines, you can naturally write sequential code that is cooperatively
scheduled. If your business logic is complex, coroutines could greatly improve
readability of asynchronous I/O code.</p>
<p>However for a single task, asynchronous I/O can actually impair throughput. For
example, for a simple <code class="docutils literal notranslate"><span class="pre">recv()</span></code> operation blocking I/O would just block until
returning the result, but for asynchronous I/O additional steps are required:
register for the read event, wait until event arrives, try to <code class="docutils literal notranslate"><span class="pre">recv()</span></code>, repeat
until a result returns, and finally feed the result to a callback. With coroutines,
the framework cost is even larger. Thanks to <a class="reference external" href="https://github.com/MagicStack/uvloop">uvloop</a> this cost has been minimized
in Python, but it is still additional overhead compared to raw blocking I/O.</p>
<p>Timing in Asynchronous I/O is also less predictable because of its cooperative
nature. For example, in a coroutine you may want to sleep for 1 second. However,
if another coroutine received control and ran for 2 seconds, by the time we get
back to the first coroutine 2 seconds have already passed. Therefore, <code class="docutils literal notranslate"><span class="pre">sleep(1)</span></code>
means to wait for at least 1 second. In practice, you should try your best to make
sure that all code between <code class="docutils literal notranslate"><span class="pre">await</span></code> finishes ASAP, being literally cooperative.
Still, there can be code outside your control, so it is important to keep this
unpredictibility of timing in mind.</p>
<p>Finally, asynchronous programming is complicated. Writing good asynchronous code
is easier said than done, and debugging it is more difficult than debugging
similar synchronous code. Especially when a whole team is working on the
same piece of asynchronous code, it can easily go wrong. Therefore, a general
suggestion is to use asynchronous I/O carefully for I/O-bound high concurrency
scenarios only. It's not a drop-in that will provide a performance boost, but
more like a sharp blade for concurrency with two edges. And if you are dealing with
time-critical tasks, think again to be sure.</p>
</div>
</div>


            </div>
            <p style="text-align: center; font-size: 12px;">
                <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
                    <img
                        alt="知识共享许可协议"
                        style="border-width:0"
                        src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
                    />
                </a>
                <br/>
                本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。
            </p>
        </div>

        <div class="col hide-on-small-only m3 right-nav">
            <div class="table-of-contents fixed">
                
                    <ul>
<li><a class="reference internal" href="#">异步编程基础</a><ul>
<li><a class="reference internal" href="#the-story">一个经典场景</a></li>
<li><a class="reference internal" href="#cooperative-multitasking">Cooperative multitasking</a></li>
<li><a class="reference internal" href="#pros-and-cons">Pros and cons</a></li>
</ul>
</li>
</ul>

                
                <div id="version-selector">
                    
                        <hr>
                    
                </div>
                <div class="add-your-lang">
                    <a href="https://www.transifex.com/decentfox-studio/gino_1_0/"
                       target="_blank">Add your language here.</a>
                </div>
            </div>
        </div>

    </div>
    <div class="fixed-action-btn click-to-toggle">
        <a class="btn-floating btn-large white">
            <img src="../_static/images/language.svg">
            <div>
              ZH
            </div>
        </a>
        <ul id="lang-selector">
        </ul>
    </div>
</main>

<script type="text/javascript" src="../_static/js/materialize.min.js"></script>
<script type="text/javascript" src="../_static/js/language_data.js"></script>
<script id="documentation_options" data-url_root="../" src="../_static/js/documentation_options.js"></script>
<script type="text/javascript" src="../_static/js/underscore.js"></script>
<script type="text/javascript" src="../_static/js/jquery.js"></script>
<script type="text/javascript">
    var sver = 'master';
    var language = 'zh';
    var pagename = 'explanation/async';
</script>
<script type="text/javascript" src="../_static/js/gino.js"></script>
<script type="text/javascript" src="../searchindex.js"></script>
</body>
</html>